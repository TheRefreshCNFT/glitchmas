<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; overflow: hidden; background-color: black; }
    canvas { display: block; touch-action: none; }
    .modal {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: #111; padding: 20px; border-radius: 10px; border: 1px solid #333;
    display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.2); z-index: 10;
}
.modal button {
    padding: 10px; background: #000; color: gold; border: 1px solid #333;
    font-weight: bold; cursor: pointer; box-shadow: 0 0 5px rgba(255, 215, 0, 0.2);
    font-family: monospace;
}
.modal button:hover { background: #222; }
  </style>
</head>
<body>
<canvas id="patternCanvas"></canvas>
<script>
  const canvas = document.getElementById("patternCanvas");
  const ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const shapes = [];
  const numShapes = 5; 
  const maxOverlapRatio = 0.6; 
  let globalTime = 0; 

  const colors = [
    "hsl(180, 100%, 70%)", "hsl(200, 100%, 70%)", "hsl(220, 100%, 80%)",
    "hsl(280, 100%, 75%)", "hsl(320, 100%, 70%)", "hsl(0, 0%, 90%)",
    "hsl(150, 100%, 80%)", "hsl(250, 100%, 85%)" 
  ];

  function normalizeVector(vec) {
    const mag = Math.hypot(vec.x, vec.y);
    return { x: vec.x / mag, y: vec.y / mag };
  }

  // --- Noise Functions ---
  const noiseSeed = new Float32Array(512);
  for (let i = 0; i < 512; i++) noiseSeed[i] = Math.random();

  function noise(x) {
    const scaledX = Math.abs(x); 
    const i = Math.floor(scaledX) % 512;
    const f = scaledX - Math.floor(scaledX);
    const u = f * f * (3 - 2 * f); 
    return lerp(noiseSeed[i], noiseSeed[(i + 1) % 512], u);
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function getVisualRadius(shape) {
  // Worst-case outer layer radius: progressâ‰ˆ0 => radius, plus (noise*20) up to 20, plus breath up to 10
  const outer = shape.radius + 30;

  // Rebuild the same transform terms used in drawShape()
  const scale = Math.cos(shape.rotX);
  const skew = Math.sin(shape.rotY) * 1.3;
  const visualScale = Math.max(0.2, Math.abs(scale));

  const a = 1 + shape.rotationAxis.x * skew;
  const b = shape.rotationAxis.y * skew;
  const c = shape.rotationAxis.x * skew;
  const d = 1 + shape.rotationAxis.y * skew;

  // This is the actual 2x2 matrix you apply via ctx.transform(...)
  const m00 = a * visualScale;
  const m01 = c;
  const m10 = b;
  const m11 = d * visualScale;

  // Largest singular value (max stretch factor) of the 2x2 matrix
  const s1 = m00*m00 + m01*m01 + m10*m10 + m11*m11;
  const s2 = (m00*m00 + m01*m01 - m10*m10 - m11*m11);
  const s3 = (m00*m10 + m01*m11);
  const sigmaMax = Math.sqrt((s1 + Math.sqrt(s2*s2 + 4*s3*s3)) / 2);

  return outer * sigmaMax;
}



function initializeShapes() {
    shapes.length = 0;
    const maxRadius = Math.min(canvas.width, canvas.height) / 2.5; 

    let attempts = 0;
    while (shapes.length < numShapes && attempts < 2000) {
      
      const minRadius = maxRadius * 0.4;
      const radius = Math.random() * (maxRadius - minRadius) + minRadius;

      // GEOMETRY
      const possibleSymmetries = [5, 6, 7, 8, 9, 12, 16, 20]; 
      const symmetry = possibleSymmetries[Math.floor(Math.random() * possibleSymmetries.length)];
      const step = Math.floor(Math.random() * (symmetry / 2 - 1)) + 2; 
      const patternType = Math.floor(Math.random() * 2);

      // Generate Random Base Position
      const safeWidth = canvas.width - (radius * 2);
      const safeHeight = canvas.height - (radius * 2);
      
      const randomX = safeWidth > 0 ? Math.random() * safeWidth + radius : canvas.width / 2;
      const randomY = safeHeight > 0 ? Math.random() * safeHeight + radius : canvas.height / 2;

      const newShape = {
        baseX: randomX,
        baseY: randomY,
        x: randomX, 
        y: randomY,
        
        radius,
        symmetry,
        step,
        patternType, 
        spikeFactor: Math.random() * 0.5 + 0.5, 
        twistFactor: (Math.random() - 0.5) * 0.1, 

        phase: Math.random() * Math.PI * 2,
        lineDensity: Math.floor(Math.random() * 25) + 25,
        color: colors[Math.floor(Math.random() * colors.length)],
        
        // MOVEMENT RANDOMIZERS
        timeOffset: Math.random() * 1000, 
        walkSpeedMult: Math.random() * 0.5 + 0.5, 
        walkRangeMult: Math.random() * 0.5 + 0.75, 
        
        // PHYSICS
        rotX: (Math.random() - 0.5) * 0.5,
        rotY: (Math.random() - 0.5) * 0.5, 
        velX: 0, 
        velY: 0,
        
        rotationAxis: normalizeVector({ x: Math.random() - 0.5, y: Math.random() - 0.5 })
      };

      // --- PRE-CALCULATE POSITION ---
      // We calculate the drift immediately so we check overlap on the VISUAL position
      const t = 0 + newShape.timeOffset; 
      const walkRange = canvas.width * 0.25 * newShape.walkRangeMult;
      const walkSpeed = t * 0.4 * newShape.walkSpeedMult;
      
      let calcX = newShape.baseX + (Math.sin(walkSpeed) * walkRange + Math.cos(walkSpeed * 0.3) * (walkRange * 0.3));
      let calcY = newShape.baseY + (Math.cos(walkSpeed * 0.7) * (walkRange * 0.15));

      // Apply Boundary Clamping
      if (calcX - newShape.radius < 0) calcX = newShape.radius;
      if (calcX + newShape.radius > canvas.width) calcX = canvas.width - newShape.radius;
      if (calcY - newShape.radius < 0) calcY = newShape.radius;
      if (calcY + newShape.radius > canvas.height) calcY = canvas.height - newShape.radius;

      newShape.x = calcX;
      newShape.y = calcY;

      // --- VISUAL OVERLAP CHECK ---
      let valid = true;
      for (let shape of shapes) {
        // Check distance between ACTUAL positions (x,y), not invisible anchors (baseX, baseY)
        const dx = shape.x - newShape.x;
        const dy = shape.y - newShape.y;
        const dist = Math.hypot(dx, dy);
        
const r1 = getVisualRadius(shape);
const r2 = getVisualRadius(newShape);

const minDist = r1 + r2;
const maxOverlap = Math.min(r1, r2) * maxOverlapRatio;

        
        if (dist < (minDist - maxOverlap)) {
          valid = false;
          break;
        }
      }

      if (valid) {
        shapes.push(newShape);
      }
      attempts++;
    }
  }


  function updateShapes() {
    for (let shape of shapes) {
      
      // --- 1. RANDOMIZED WALKING ---
      const t = globalTime + shape.timeOffset;
      
      const walkRange = canvas.width * 0.25 * shape.walkRangeMult;
      const walkSpeed = t * 0.4 * shape.walkSpeedMult;
      
      const driftX = Math.sin(walkSpeed) * walkRange + Math.cos(walkSpeed * 0.3) * (walkRange * 0.3);
      const driftY = Math.cos(walkSpeed * 0.7) * (walkRange * 0.15); 

      let newX = shape.baseX + driftX;
      let newY = shape.baseY + driftY;

      // UPDATED: Boundary Clamping
      // This forces the shape to stay within the visible canvas
      if (newX - shape.radius < 0) newX = shape.radius;
      if (newX + shape.radius > canvas.width) newX = canvas.width - shape.radius;
      if (newY - shape.radius < 0) newY = shape.radius;
      if (newY + shape.radius > canvas.height) newY = canvas.height - shape.radius;

      shape.x = newX;
      shape.y = newY;

      // --- 2. ROTATION PHYSICS (The 65% Rule) ---
      const stateVal = noise(t * 0.1); 
      
      let springStiffness = 0;
      
      if (stateVal > 0.35) {
        springStiffness = 0.002; // Magnetic Pull
      } else {
        springStiffness = 0.0001; // Free Float
      }

      const forceX = -shape.rotX * springStiffness;
      const forceY = -shape.rotY * springStiffness;

      // Add Random Turbulence (Wind)
      const turbulenceX = (Math.random() - 0.5) * 0.002;
      const turbulenceY = (Math.random() - 0.5) * 0.002;

      shape.velX += forceX + turbulenceX;
      shape.velY += forceY + turbulenceY;

      shape.velX *= 0.96;
      shape.velY *= 0.96;

      shape.rotX += shape.velX;
      shape.rotY += shape.velY;

      // --- 3. INTERNAL ANIMATION ---
      shape.phase += 0.002; 
    }

      // --- ENFORCE MAX OVERLAP (maxOverlapRatio) ON VISUAL POSITIONS ---
  for (let i = 0; i < shapes.length; i++) {
    for (let j = i + 1; j < shapes.length; j++) {
      const s1 = shapes[i];
      const s2 = shapes[j];

      const r1 = getVisualRadius(s1);
      const r2 = getVisualRadius(s2);

      const allowedOverlap = Math.min(r1, r2) * maxOverlapRatio;
      const minDist = (r1 + r2) - allowedOverlap;

      let dx = s2.x - s1.x;
      let dy = s2.y - s1.y;
      let dist = Math.hypot(dx, dy);

      if (dist === 0) {
        dx = (Math.random() - 0.5) * 0.001;
        dy = (Math.random() - 0.5) * 0.001;
        dist = Math.hypot(dx, dy);
      }

      if (dist < minDist) {
        const push = (minDist - dist) * 0.5;
        const nx = dx / dist;
        const ny = dy / dist;

        // Push apart (and persist by shifting baseX/baseY too)
        s1.x -= nx * push;  s1.y -= ny * push;
        s2.x += nx * push;  s2.y += ny * push;

        s1.baseX -= nx * push;  s1.baseY -= ny * push;
        s2.baseX += nx * push;  s2.baseY += ny * push;

        // Clamp base positions using the same radius logic you already use
        if (s1.baseX - s1.radius < 0) s1.baseX = s1.radius;
        if (s1.baseX + s1.radius > canvas.width) s1.baseX = canvas.width - s1.radius;
        if (s1.baseY - s1.radius < 0) s1.baseY = s1.radius;
        if (s1.baseY + s1.radius > canvas.height) s1.baseY = canvas.height - s1.radius;

        if (s2.baseX - s2.radius < 0) s2.baseX = s2.radius;
        if (s2.baseX + s2.radius > canvas.width) s2.baseX = canvas.width - s2.radius;
        if (s2.baseY - s2.radius < 0) s2.baseY = s2.radius;
        if (s2.baseY + s2.radius > canvas.height) s2.baseY = canvas.height - s2.radius;

        // Clamp the current draw positions too
        if (s1.x - s1.radius < 0) s1.x = s1.radius;
        if (s1.x + s1.radius > canvas.width) s1.x = canvas.width - s1.radius;
        if (s1.y - s1.radius < 0) s1.y = s1.radius;
        if (s1.y + s1.radius > canvas.height) s1.y = canvas.height - s1.radius;

        if (s2.x - s2.radius < 0) s2.x = s2.radius;
        if (s2.x + s2.radius > canvas.width) s2.x = canvas.width - s2.radius;
        if (s2.y - s2.radius < 0) s2.y = s2.radius;
        if (s2.y + s2.radius > canvas.height) s2.y = canvas.height - s2.radius;
      }
    }
  }

  }

  function drawShape(shape) {
    const { x, y, radius, symmetry, step, patternType, spikeFactor, twistFactor, phase, lineDensity, color, rotX, rotY, rotationAxis } = shape;

    ctx.save();
    ctx.translate(x, y);

    // --- 3D TRANSFORM ---
    const scale = Math.cos(rotX); 
    const skew = Math.sin(rotY) * 1.3; 
    const visualScale = Math.max(0.2, Math.abs(scale)); 
    
    const a = 1 + rotationAxis.x * skew;
    const b = rotationAxis.y * skew;
    const c = rotationAxis.x * skew;
    const d = 1 + rotationAxis.y * skew;
    
    ctx.transform(a * visualScale, b, c, d * visualScale, 0, 0);

    // --- DRAWING ---
    ctx.lineWidth = 1.25; 
    
    for (let i = 0; i < lineDensity; i++) {
        const progress = i / lineDensity;
        
        // Organic flowing radius
        const layerNoise = noise(i * 0.15 + (globalTime + shape.timeOffset) * 0.1); 
        const breath = Math.sin((globalTime + shape.timeOffset) * 0.5 + i * 0.05) * 10;
        
        const currentRadius = radius * (1 - progress * 0.85) + (layerNoise * 20) + breath;

        // Alpha calculation
        const alpha = (1 - progress) * 0.8 + 0.15;
        const shade = Math.floor(180 + layerNoise * 75);
        ctx.strokeStyle = `rgba(${shade}, ${shade}, ${shade}, ${alpha})`;

        ctx.beginPath();
        const points = [];

        // --- PATTERN ALGORITHMS ---
        
        if (patternType === 0) { 
            // TYPE 0: THE WEAVER
            for (let j = 0; j < symmetry; j++) {
                const angle = (Math.PI * 2 / symmetry) * j + phase + (i * 0.015); 
                points.push({
                    x: Math.cos(angle) * currentRadius,
                    y: Math.sin(angle) * currentRadius
                });
            }
        } 
        else if (patternType === 1) { 
            // TYPE 1: THE STARBURST
            for (let j = 0; j < symmetry * 2; j++) {
                const angle = (Math.PI * 2 / (symmetry * 2)) * j + phase + (i * 0.015);
                const r = (j % 2 === 0) ? currentRadius : currentRadius * spikeFactor;
                points.push({
                    x: Math.cos(angle) * r,
                    y: Math.sin(angle) * r
                });
            }
        } 
        else if (patternType === 2) { 
            // TYPE 2: THE TURBINE
            for (let j = 0; j < symmetry; j++) {
                const twist = i * twistFactor; 
                const angle = (Math.PI * 2 / symmetry) * j + phase + twist;
                points.push({
                    x: Math.cos(angle) * currentRadius,
                    y: Math.sin(angle) * currentRadius
                });
            }
        }

        // --- CONNECTING THE DOTS ---
        
        if (patternType === 0) {
            for (let j = 0; j < points.length; j++) {
                const p1 = points[j];
                const p2 = points[(j + 2) % points.length]; 
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            }
        } else {
            for (let j = 0; j < points.length; j++) {
                const p1 = points[j];
                const p2 = points[(j + step) % points.length]; 
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            }
        }
        
        ctx.stroke();
    }
    
    // Core Glow
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.07;
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.25, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }


  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    updateShapes();
    for (let shape of shapes) {
      drawShape(shape);
    }
    globalTime += 0.005; 
    requestAnimationFrame(animate);
  }

  initializeShapes();
  animate();

  window.addEventListener("resize", () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    initializeShapes();
  });

// --- UPDATED CLICK/DOUBLE-CLICK LOGIC ---
    let tapTimer;
    let lastTapTime = 0;
    
    // We handle both single and double clicks in one listener
    // This fixes the race condition on iPadOS
    document.getElementById("patternCanvas").addEventListener('click', (e) => {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTapTime;

        // Clear any pending reload from the previous tap
        clearTimeout(tapTimer);

        if (tapLength < 275 && tapLength > 0) {
            // --- DOUBLE CLICK DETECTED ---
            // (User tapped twice within 500ms)
            showModal();
            
            // Prevent the third click if the user is mashing buttons
            e.preventDefault(); 
        } else {
            // --- SINGLE CLICK DETECTED ---
            // Wait 300ms to see if a second tap comes. 
            // If not, reload.
            tapTimer = setTimeout(() => {
                location.reload();
            }, 300);
        }

        lastTapTime = currentTime;
    });

 function showModal() {
             const options = ['1k', '2k', '3k', '4k', '8k', '16k'];
             const modal = document.createElement('div');
             modal.className = 'modal';
             if (modal) {
               modal.style.background = "#000";
               modal.style.boxShadow = `0 0 10px hsl(310, 100%, 50%)`;
             }
             options.forEach(opt => {
                 const btn = document.createElement('button');
                 btn.textContent = opt;
                 btn.onclick = () => {
                     document.body.removeChild(modal);
                     scaleCanvas(parseInt(opt), opt.includes('t'));
                 };
                 modal.appendChild(btn);
                 if (btn) {
                   btn.style.background = "#000";
                   btn.style.color = 'hsl(310, 100%, 50%)';
                   btn.style.boxShadow = `0 0 10px hsl(310, 100%, 50%)`;
                 }
               });
             document.body.appendChild(modal);
         }

         function scaleCanvas(multiplier, transparent) {
    const originalAspectRatio = canvas.width / canvas.height;
    const upscaleHeight = 1024 * multiplier;
    const upscaleWidth = upscaleHeight * originalAspectRatio;

    const offscreenCanvas = document.createElement('canvas');
    const offscreenCtx = offscreenCanvas.getContext('2d');
    offscreenCanvas.width = upscaleWidth;
    offscreenCanvas.height = upscaleHeight;

    if (!transparent) {
        offscreenCtx.fillStyle = '#000000';
        offscreenCtx.fillRect(0, 0, upscaleWidth, upscaleHeight);
    }

    const scale = upscaleHeight / canvas.height;
    const scaledWidth = canvas.width * scale;
    const scaledHeight = canvas.height * scale;
    const offsetX = (upscaleWidth - scaledWidth) / 2;
    const offsetY = (upscaleHeight - scaledHeight) / 2;

    offscreenCtx.drawImage(canvas, offsetX, offsetY, scaledWidth, scaledHeight);

    const link = document.createElement('a');
    link.download = `MerryGlitchmas_${multiplier}k.png`;
    link.href = offscreenCanvas.toDataURL('image/png');
    link.click();
}
</script>
</body>
</html>
